
import java.awt.Color;
import java.awt.Font;
import java.util.ArrayList;
import javax.swing.BorderFactory;
import javax.swing.JOptionPane;
import javax.swing.JTextField;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author PhuocAn
 */
public class MainScreen extends javax.swing.JFrame {
    
    ArrayList<JTextField> textList = new ArrayList<>();
    ArrayList<boolean[]> possibleValueList = new ArrayList<>();
    int[][] matrix = new int[9][9];
    int finishedCell;

    /**
     * Creates new form MainScreen
     */
    public MainScreen() {
        initComponents();
        this.pnMain.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
        for (int i = 1; i < 10; i++) {
            for (int j = 1; j < 10; j++) {
                JTextField textField = new JTextField();
                /*Create border*/
                int top, left, bottom, right;
                /*Create border: row 1, 4, 7 create top border*/
                top = (i == 1 || i == 4 || i == 7) ? 3 : 0;
                /*Create border: row 9 create bottom border*/
                bottom = (i == 9) ? 3 : 0;
                /*Create border: column 1, 4, 7 create left border*/
                left = (j == 1 || j == 4 || j == 7) ? 3 : 0;
                /*Create border: column 9 create right border*/
                right = (j == 9) ? 3 : 0;
                MatteBorder outside = BorderFactory.createMatteBorder(top, left, bottom, right, Color.GRAY);
                EmptyBorder inside = (EmptyBorder) BorderFactory.createEmptyBorder(2, 15, 2, 5);
                textField.setBorder(BorderFactory.createCompoundBorder(outside, inside));
                Font font = textField.getFont();
                textField.setFont(new Font(font.getFamily(), font.getStyle(), 20));
                textList.add(textField);
                this.pnMain.add(textField);
            }
        }
        this.setTitle("Sudoku Solver");
        this.setSize(400, 400);
        this.setResizable(false);
//        this.btnLoadDefault.setEnabled(false);
        this.btnShowHint.setEnabled(false);
        this.btnHideHint.setEnabled(false);
        this.btnGuess.setEnabled(false);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        pnMain = new javax.swing.JPanel();
        jPanel2 = new javax.swing.JPanel();
        btnSolve = new javax.swing.JButton();
        btnGuess = new javax.swing.JButton();
        btnNew = new javax.swing.JButton();
        btnLoadDefault = new javax.swing.JButton();
        btnShowHint = new javax.swing.JButton();
        btnHideHint = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        pnMain.setLayout(new java.awt.GridLayout(9, 9));
        getContentPane().add(pnMain, java.awt.BorderLayout.CENTER);

        btnSolve.setText("Solve");
        btnSolve.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSolveActionPerformed(evt);
            }
        });
        jPanel2.add(btnSolve);

        btnGuess.setText("Guess");
        btnGuess.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGuessActionPerformed(evt);
            }
        });
        jPanel2.add(btnGuess);

        btnNew.setText("New");
        btnNew.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnNewActionPerformed(evt);
            }
        });
        jPanel2.add(btnNew);

        btnLoadDefault.setText("Load");
        btnLoadDefault.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnLoadDefaultActionPerformed(evt);
            }
        });
        jPanel2.add(btnLoadDefault);

        btnShowHint.setText("Show hint");
        btnShowHint.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnShowHintActionPerformed(evt);
            }
        });
        jPanel2.add(btnShowHint);

        btnHideHint.setText("Hide");
        btnHideHint.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnHideHintActionPerformed(evt);
            }
        });
        jPanel2.add(btnHideHint);

        getContentPane().add(jPanel2, java.awt.BorderLayout.PAGE_END);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Solve the puzzle
     *
     * @param evt
     */
    private void btnSolveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSolveActionPerformed
        // TODO add your handling code here:
        System.out.println("=========================Start solve puzzle=======================");
        btnSolveAction();
        this.btnGuess.setEnabled(true);
        this.btnLoadDefault.setEnabled(false);
        this.btnSolve.setEnabled(false);
    }//GEN-LAST:event_btnSolveActionPerformed

    /**
     * Clear all cell for new puzzle
     *
     * @param evt
     */
    private void btnNewActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnNewActionPerformed
        // TODO add your handling code here:
        for (JTextField textField : this.textList) {
            Font font = textField.getFont();
            textField.setFont(new Font(font.getFamily(), font.getStyle(), 20));
            textField.setText("");
        }
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                matrix[i][j] = 0;
            }
        }
        this.btnGuess.setEnabled(false);
        this.btnLoadDefault.setEnabled(true);
        this.btnSolve.setEnabled(true);
    }//GEN-LAST:event_btnNewActionPerformed

    /**
     * Quickly load a puzzle
     *
     * @param evt
     */
    private void btnLoadDefaultActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnLoadDefaultActionPerformed
        // TODO add your handling code here:
        int[] defaultValues = {
            0, 0, 0, 0, 0, 3, 0, 0, 0,
            2, 0, 0, 0, 4, 9, 0, 0, 6,
            0, 6, 7, 0, 0, 0, 0, 0, 8,
            0, 7, 0, 0, 0, 2, 9, 0, 0,
            0, 2, 0, 0, 0, 0, 0, 1, 0,
            0, 0, 5, 3, 0, 0, 0, 6, 0,
            8, 0, 0, 0, 0, 0, 5, 3, 0,
            1, 0, 0, 6, 2, 0, 0, 0, 9,
            0, 0, 0, 9, 0, 0, 0, 0, 0
        };
        for (int i = 0; i < 81; i++) {
            if (defaultValues[i] != 0) {
                this.textList.get(i).setText(defaultValues[i] + "");
            }
        }
        this.btnGuess.setEnabled(false);
    }//GEN-LAST:event_btnLoadDefaultActionPerformed

    /**
     * Show possible values for all unsolved cells
     *
     * @param evt
     */
    private void btnShowHintActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnShowHintActionPerformed
        // TODO add your handling code here:
        showPossibleValues();
    }//GEN-LAST:event_btnShowHintActionPerformed

    /**
     * Hide possible values of all unsolved cells
     *
     * @param evt
     */
    private void btnHideHintActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnHideHintActionPerformed
        // TODO add your handling code here:
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (matrix[i][j] == 0) {
                    JTextField tmpTextField = this.textList.get(i * 9 + j);
                    Font font = tmpTextField.getFont();
                    tmpTextField.setFont(new Font(font.getFamily(), font.getStyle(), 20));
                    tmpTextField.setText("");
                }
            }
        }
    }//GEN-LAST:event_btnHideHintActionPerformed

    /**
     * If the puzzle could not solved after btnSolveActionPerform, try to guess
     * some cell, then continue to solve it
     *
     * @param evt
     */
    private void btnGuessActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGuessActionPerformed
        // TODO add your handling code here:
        /*Back up the progress until first guess*/
        ArrayList<boolean[]> tmpPossibleValues = new ArrayList<>();
        int[][] tmpMatrix = new int[9][9];
        duplicateLists(tmpMatrix, tmpPossibleValues, this.matrix, this.possibleValueList);
        guess(0, 0, tmpMatrix, tmpPossibleValues);
        this.btnGuess.setEnabled(false);
    }//GEN-LAST:event_btnGuessActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MainScreen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MainScreen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MainScreen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainScreen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new MainScreen().setVisible(true);
            }
        });
    }

    /**
     * Test each cell in matrix, if the cell is solved, assign value to that
     * cell
     *
     * @param row the row of cell
     * @param column the column of cell
     */
    private boolean testCell(int row, int column) {
        boolean[] possibleValue = this.possibleValueList.get(row * 9 + column);
        for (int i = 0; i < 9; i++) {
            possibleValue[i] = false;
        }
        testRow(row, possibleValue);
        int result = checkFound(possibleValue);
        if (result > 0) {
            matrix[row][column] = result;
            textList.get(row * 9 + column).setText(result + "");
            finishedCell += 1;
            System.out.println("testRow found " + result + " at position " + (row + 1) + "," + (column + 1));
            return true;
        }
        testColumn(column, possibleValue);
        result = checkFound(possibleValue);
        if (result > 0) {
            matrix[row][column] = result;
            textList.get(row * 9 + column).setText(result + "");
            finishedCell += 1;
            System.out.println("testColumn found " + result + " at position " + (row + 1) + "," + (column + 1));
            return true;
        }
        testSmallMatrix(row, column, possibleValue);
        result = checkFound(possibleValue);
        if (result > 0) {
            matrix[row][column] = result;
            textList.get(row * 9 + column).setText(result + "");
            finishedCell += 1;
            System.out.println("testSmallMatrix found " + result + " at position " + (row + 1) + "," + (column + 1));
            return true;
        }
        result = testUniqueValue(row, column);
        if (result > 0) {
            matrix[row][column] = result;
            textList.get(row * 9 + column).setText(result + "");
            finishedCell += 1;
            return true;
        }
        testDuplicate(row, column);
        return false;
    }

    /**
     * Check if value of the cell is found or not, it is found if 8 over 9 value
     * in possibleValue is true.
     *
     * @param possibleValue
     * @return -1 if there is error during finding process, 0 if value of the
     * cell is not found, 1 to 9 if the value is found
     */
    private int checkFound(boolean[] possibleValue) {
        int result = -1;    //initial is -1 mean did not check
        for (int i = 0; i < 9; i++) {
            /*False value at position i mean the cell could be this value*/
            if (!possibleValue[i]) {
                /*result equal -1 means this is the first value that the could be receive*/
                if (result == -1) {
                    result = i + 1;
                } else {    //This mean there are more than 1 possible value for the cell, return 0
                    return 0;
                }
            }
        }
        return result;
    }

    /**
     * To eliminate some values in possible values list
     *
     * @param row the row to be checked
     * @param possibleValue an array of 9 boolean value to mark if the cell
     * could eliminate which value
     */
    private void testRow(int row, boolean[] possibleValue) {
        /*Go throught row*/
        for (int i = 0; i < 9; i++) {
            if (matrix[row][i] != 0) {
                possibleValue[matrix[row][i] - 1] = true;
            }
        }
    }

    /**
     * To eliminate some values in possible values list
     *
     * @param column the column to be checked
     * @param possibleValue an array of 9 boolean value to mark if the cell
     * could eliminate which value
     */
    private void testColumn(int column, boolean[] possibleValue) {
        /*Go throught column*/
        for (int i = 0; i < 9; i++) {
            if (matrix[i][column] != 0) {
                possibleValue[matrix[i][column] - 1] = true;
            }
        }
    }

    /**
     * To eliminate some values in possible values list
     *
     * @param row the row to be checked
     * @param column the column to be checked
     * @param possibleValue an array of 9 boolean value to mark if the cell
     * could eliminate which value
     */
    private void testSmallMatrix(int row, int column, boolean[] possibleValue) {
        int startRow = row - row % 3;
        int startColumn = column - column % 3;
        for (int i = startRow; i < startRow + 3; i++) {
            for (int j = startColumn; j < startColumn + 3; j++) {
                if (matrix[i][j] != 0) {
                    possibleValue[matrix[i][j] - 1] = true;
                }
            }
        }
    }

    /**
     * Get inputted value then fill to matrix
     */
    private void fillMatrix() {
        finishedCell = 0;
        this.possibleValueList = new ArrayList<>();
        this.matrix = new int[9][9];
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                /*Add possibleValue*/
                boolean[] possibleValue = new boolean[9];
                for (int x = 0; x < 9; x++) {
                    possibleValue[x] = false;
                }
                this.possibleValueList.add(possibleValue);
                /*Get inputted value*/
                String text = textList.get(i * 9 + j).getText();
                try {
                    int value = text.equals("") ? 0 : Integer.parseInt(text);
                    /*Check range of number. Range is form 1 to 9*/
                    if (9 >= value && value >= 1) {
                        matrix[i][j] = value;
                        finishedCell += 1;
                    } else if (value == 0) {
                        matrix[i][j] = 0;
                    } else {
                        JOptionPane.showMessageDialog(this, "Please input number from 1 to 9 only");
                        return;
                    }
                } catch (NumberFormatException e) {
                    /*Check if user input number or text*/
                    JOptionPane.showMessageDialog(this, "Please input number");
                    return;
                }
            }
        }
    }

    /**
     * Get a string that contain all possible value for specific cell
     *
     * @param row
     * @param column
     * @return
     */
    private String getPossibleValue(int row, int column) {
        boolean[] possibleValue = this.possibleValueList.get(row * 9 + column);
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < 9; i++) {
            if (!possibleValue[i]) {
                result.append(i + 1);
            }
        }
        return result.toString();
    }

    /**
     * Check unsolved cells in same row or column or small matrix, if no more
     * cell hold same value, this cell should is the value
     *
     * @param row
     * @param column
     * @return
     */
    private int testUniqueValue(int row, int column) {
        boolean[] possibleValue = this.possibleValueList.get(row * 9 + column);
        for (int i = 0; i < 9; i++) {
            /*For each possible value*/
            if (!possibleValue[i]) {
                /*Check other unsolved cells in row, if no more cell hold this value, return this value*/
                boolean found = false;  //False if cannot found any other unsolved cell hold this value
                for (int j = 0; j < 9; j++) {
                    if (j == column || matrix[row][j] != 0) {
                        continue; //Only check other unsolved cells in same row
                    }
                    if (!this.possibleValueList.get(row * 9 + j)[i]) {
                        found = true;
                        break;  //If an unsolved cell in same row hold this value, stop search in row
                    }
                }
                if (!found) {
                    System.out.println("testUniqueValue.Row found " + (i + 1) + " at position " + (row + 1) + "," + (column + 1));
                    return i + 1;
                }
                /*Check other unsolved cells in column, if no more cell hold this value, return this value*/
                found = false;
                for (int j = 0; j < 9; j++) {
                    if (j == row || matrix[j][column] != 0) {
                        continue; //Only check other unsolved cells in same column
                    }
                    if (!this.possibleValueList.get(j * 9 + column)[i]) {
                        found = true;
                        break;  //If an unsolved cell in same column hold this value, stop search in column
                    }
                }
                if (!found) {
                    System.out.println("testUniqueValue.Column found " + (i + 1) + " at position " + (row + 1) + "," + (column + 1));
                    return i + 1;
                }
                /*Check other unsolved cells in same small matrix, if no more cell hold this value, return this value*/
                found = false;
                int startRow = row - row % 3;
                int startColumn = column - column % 3;
                for (int j = startRow; j < startRow + 3; j++) {
                    if (found) {
                        break;
                    }
                    for (int k = startColumn; k < startColumn + 3; k++) {
                        if ((j == row && k == column) || matrix[j][k] != 0) {
                            continue; //Only check other unsolved cells in same column
                        }
                        if (getPossibleValue(j, k).contains((i + 1) + "")) {
                            found = true;
                            break;  //If an unsolved cell in same matrix hold this value, stop search in matrix
                        }
                    }
                }
                if (!found) {
                    System.out.println("testUniqueValue.SmallMatrix found " + (i + 1) + " at position " + (row + 1) + "," + (column + 1));
                    return i + 1;
                }
            }
        }
        return 0;
    }

    /**
     * If 2 unsolved cells in same row, or column, or small matrix hold only 2
     * values and same as each other, other unsolved cells in same row, column,
     * small matrix could not hold those 2 values
     *
     * @param row
     * @param column
     */
    private void testDuplicate(int row, int column) {
        /*Check other unsolved cells in row, if they are same, modify other unsolved cells in the row*/
        String possibleString = getPossibleValue(row, column);
        /*Only check unsolved cells that hold 2 possible values*/
        if (possibleString.length() != 2 || matrix[row][column] != 0) {
            return;
        }
        int[] duplicateValues = new int[2];
        duplicateValues[0] = Integer.valueOf(possibleString) / 10;
        duplicateValues[1] = Integer.valueOf(possibleString) % 10;
        /*Check duplicate in row*/
        testDuplicateRow(row, column, possibleString, duplicateValues);
        /*Check duplicate in column*/
        testDuplicateColumn(row, column, possibleString, duplicateValues);
        /*Check duplicate in small matrix*/
        testDuplicateSmallMatrix(row, column, possibleString, duplicateValues);
    }

    /**
     * A section of testDuplicate function
     *
     * @param row
     * @param column
     * @param possibleString
     * @param duplicateValues
     */
    private void testDuplicateRow(int row, int column, String possibleString, int[] duplicateValues) {
        for (int i = 0; i < 9; i++) {
            if (i == column || matrix[row][i] != 0) {
                continue; //Only check other unsolved cells in same row
            }
            if (getPossibleValue(row, i).equals(possibleString)) {
                /*Modify other unsolved cells in the row*/
                for (int j = 0; j < 9; j++) {
                    /*do not check solved cells and 2 duplicate cells*/
                    if (matrix[row][j] != 0 || j == column || j == i) {
                        continue;
                    }
                    boolean[] possibleValue = this.possibleValueList.get(row * 9 + j);
                    possibleValue[duplicateValues[0] - 1] = true;
                    possibleValue[duplicateValues[1] - 1] = true;
                    int result = checkFound(possibleValue);
                    if (result > 0) {
                        matrix[row][j] = result;
                        textList.get(row * 9 + j).setText(result + "");
                        finishedCell += 1;
                        System.out.println("testDupicate.Row found " + result + " at position " + (row + 1) + "," + (j + 1));
                    }
                }
                break;
            }
        }
    }

    /**
     * A section of testDuplicate function
     *
     * @param row
     * @param column
     * @param possibleString
     * @param duplicateValues
     */
    private void testDuplicateColumn(int row, int column, String possibleString, int[] duplicateValues) {
        for (int i = 0; i < 9; i++) {
            if (i == row || matrix[i][column] != 0) {
                continue; //Only check other unsolved cells in same row
            }
            if (getPossibleValue(i, column).equals(possibleString)) {
                /*Modify other unsolved cells in the column*/
                for (int j = 0; j < 9; j++) {
                    /*do not check solved cells and 2 duplicate cells*/
                    if (matrix[j][column] != 0 || j == row || j == i) {
                        continue;
                    }
                    boolean[] possibleValue = this.possibleValueList.get(j * 9 + column);
                    possibleValue[duplicateValues[0] - 1] = true;
                    possibleValue[duplicateValues[1] - 1] = true;
                    int result = checkFound(possibleValue);
                    if (result > 0) {
                        matrix[j][column] = result;
                        textList.get(j * 9 + column).setText(result + "");
                        finishedCell += 1;
                        System.out.println("testDupicate.Column found " + result + " at position " + (j + 1) + "," + (column + 1));
                    }
                }
                break;
            }
        }
    }

    /**
     * A section of testDuplicate function
     *
     * @param row
     * @param column
     * @param possibleString
     * @param duplicateValues
     */
    private void testDuplicateSmallMatrix(int row, int column, String possibleString, int[] duplicateValues) {
        int startRow = row - row % 3;
        int startColumn = column - column % 3;
        for (int i = startRow; i < startRow + 3; i++) {
            for (int j = startColumn; j < startColumn + 3; j++) {
                if ((i == row && j == column) || matrix[i][j] != 0) {
                    continue; //Only check other unsolved cells in same column
                }
                if (getPossibleValue(i, j).equals(possibleString)) {
                    /*Modify other unsolved cells in the row*/
                    for (int k = startRow; k < startRow + 3; k++) {
                        for (int l = startColumn; l < startColumn + 3; l++) {
                            /*do not check solved cells and 2 duplicate cells*/
                            if (matrix[k][l] != 0 || (k == row && l == column) || (k == i && l == j)) {
                                continue;
                            }
                            boolean[] possibleValue = this.possibleValueList.get(k * 9 + l);
                            possibleValue[duplicateValues[0] - 1] = true;
                            possibleValue[duplicateValues[1] - 1] = true;
                            int result = checkFound(possibleValue);
                            if (result > 0) {
                                matrix[k][l] = result;
                                textList.get(k * 9 + l).setText(result + "");
                                finishedCell += 1;
                                System.out.println("testDupicate.SmallMatrix found " + result + " at position " + (k + 1) + "," + (l + 1));
                            }
                        }
                    }
                    break;
                }
            }
        }
    }

    /**
     * function of btnShowHint
     */
    private void showPossibleValues() {
        /*Show all possible value of cells that are not solved*/
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (matrix[i][j] == 0) {
                    JTextField tmpTextField = this.textList.get(i * 9 + j);
                    Font font = tmpTextField.getFont();
                    tmpTextField.setFont(new Font(font.getFamily(), font.getStyle(), 12));
                    tmpTextField.setText(getPossibleValue(i, j));
                }
            }
        }
    }

    /**
     * Uncompleted method, the idea is if there are 2 cell in same row column,
     * small matrix hold more than 2 values; but 2 in those values are hold by
     * these 2 cells only, so other cells could not hold those 2 values
     *
     * @param row
     * @param column
     */
    private void testDuplicateTriple(int row, int column) {
        /*Check other unsolved cells in row, if they are same, modify other unsolved cells in the row*/
        String possibleString = getPossibleValue(row, column);
        /*Only check unsolved cells that hold 3 possible values*/
        if (possibleString.length() != 3 || matrix[row][column] != 0) {
            return;
        }
        /*Check duplicate in row*/
        for (int i = 0; i < 9; i++) {
            int[] dupplicateValues = new int[3];
            dupplicateValues[0] = Integer.valueOf(possibleString) / 100;
            dupplicateValues[1] = (Integer.valueOf(possibleString) / 10) % 10;
            dupplicateValues[2] = Integer.valueOf(possibleString) % 10;
            int removedCount = 0;  //Count how many common values is remove from list
            int removedPosition = -1;
            if (i == column || matrix[row][i] != 0) {
                continue; //Only check other unsolved cells in same row
            }
            if (getPossibleValue(row, i).equals(possibleString)) {
                /*Check other unsolved cells in the row*/
                for (int j = 0; j < 9; j++) {
                    /*do not check solved cells and 2 duplicate cells*/
                    if (matrix[row][j] != 0 || j == column || j == i) {
                        continue;
                    }
                    /*We expect there are 2 common values of these 2 cells*/
                    if (removedCount > 1) {
                        break;
                    }
                    boolean[] possibleValue = this.possibleValueList.get(row * 9 + j);
                    for (int k = 0; k < 3; k++) {
                        if (removedPosition != k) {
                            if (!possibleValue[dupplicateValues[k] - 1]) {
                                removedPosition = k;
                                removedCount += 1;
                            }
                        }
                    }
                }
                /*Modify unsolved cells in the row if these 2 cells hold only 2 common values*/
                if (removedCount == 1) {
                    for (int j = 0; j < 9; j++) {
                        /*do not check solved cells*/
                        if (matrix[row][j] != 0) {
                            continue;
                        }
                        boolean[] possibleValue = this.possibleValueList.get(row * 9 + j);
                        /*in case of 2 duplicate cells*/
                        if (j == column || j == i) {
                            possibleValue[dupplicateValues[removedPosition] - 1] = true;
                            continue;
                        }
                        /*In case of other unsolved cells*/
                        for (int k = 0; k < 3; k++) {
                            if (k != removedPosition) {
                                possibleValue[dupplicateValues[k] - 1] = true;
                            }
                        }
                        int result = checkFound(possibleValue);
                        if (result > 0) {
                            matrix[row][j] = result;
                            textList.get(row * 9 + j).setText(result + "");
                            finishedCell += 1;
                            System.out.println("testDupicateTriple.Row found " + result + " at position " + (row + 1) + "," + (j + 1));
                        }
                    }
                }
                break;
            }
        }
        /*Check duplicate in column*/
        for (int i = 0; i < 9; i++) {
            int[] dupplicateValues = new int[3];
            dupplicateValues[0] = Integer.valueOf(possibleString) / 100;
            dupplicateValues[1] = (Integer.valueOf(possibleString) / 10) % 10;
            dupplicateValues[2] = Integer.valueOf(possibleString) % 10;
            int removedCount = 0;  //Count how many common values is remove from list
            int removedPosition = -1;
            if (i == row || matrix[i][column] != 0) {
                continue; //Only check other unsolved cells in same column
            }
            if (getPossibleValue(i, column).equals(possibleString)) {
                /*Check other unsolved cells in the column*/
                for (int j = 0; j < 9; j++) {
                    /*We expect there are 2 common values of these 2 cells*/
                    if (removedCount > 1) {
                        break;
                    }
                    /*do not check solved cells and 2 duplicate cells*/
                    if (matrix[j][column] != 0 || j == row || j == i) {
                        continue;
                    }
                    boolean[] possibleValue = this.possibleValueList.get(row * 9 + j);
                    for (int k = 0; k < 3; k++) {
                        if (k != removedPosition) {
                            if (!possibleValue[dupplicateValues[k] - 1]) {
                                removedPosition = k;
                                removedCount += 1;
                            }
                        }
                    }
                }
                /*Modify unsolved cells in the column if these 2 cells hold only 2 common values*/
                if (removedCount == 1) {
                    for (int j = 0; j < 9; j++) {
                        /*do not check solved cells*/
                        if (matrix[j][column] != 0) {
                            continue;
                        }
                        boolean[] possibleValue = this.possibleValueList.get(j * 9 + column);
                        /*in case of 2 duplicate cells*/
                        if (j == row || j == i) {
                            possibleValue[dupplicateValues[removedPosition] - 1] = true;
                            continue;
                        }
                        /*In case of other unsolved cells*/
                        for (int k = 0; k < 3; k++) {
                            if (k != removedPosition) {
                                possibleValue[dupplicateValues[k] - 1] = true;
                            }
                        }
                        int result = checkFound(possibleValue);
                        if (result > 0) {
                            matrix[j][column] = result;
                            textList.get(j * 9 + column).setText(result + "");
                            finishedCell += 1;
                            System.out.println("testDupicateTriple.Column found " + result + " at position " + (j + 1) + "," + (column + 1));
                        }
                    }
                }
                break;
            }
        }
        /*Check duplicate in small matrix*/
        int startRow = row - row % 3;
        int startColumn = column - column % 3;
        for (int i = startRow; i < startRow + 3; i++) {
            for (int j = startColumn; j < startColumn + 3; j++) {
                int[] dupplicateValues = new int[3];
                dupplicateValues[0] = Integer.valueOf(possibleString) / 100;
                dupplicateValues[1] = (Integer.valueOf(possibleString) / 10) % 10;
                dupplicateValues[2] = Integer.valueOf(possibleString) % 10;
                int removedCount = 0;  //Count how many common values is remove from list
                int removedPosition = -1;
                if ((i == row && j == column) || matrix[i][j] != 0) {
                    continue; //Only check other unsolved cells in same matrix
                }
                if (getPossibleValue(i, j).equals(possibleString)) {
                    /*Check other unsolved cells in the matrix*/
                    for (int k = startRow; k < startRow + 3; k++) {
                        for (int l = startColumn; l < startColumn + 3; l++) {
                            /*We expect there are 2 common values of these 2 cells*/
                            if (removedCount > 1) {
                                break;
                            }
                            /*do not check solved cells and 2 duplicate cells*/
                            if (matrix[k][l] != 0 || (k == i && l == j) || (k == row && l == column)) {
                                continue;
                            }
                            boolean[] possibleValue = this.possibleValueList.get(k * 9 + l);
                            for (int m = 0; m < 3; m++) {
                                if (m != removedPosition) {
                                    if (!possibleValue[dupplicateValues[m] - 1]) {
                                        removedPosition = m;
                                        removedCount += 1;
                                    }
                                }
                            }
                        }
                    }
                    /*Modify unsolved cells in the column if these 2 cells hold only 2 common values*/
                    if (removedCount == 1) {
                        for (int k = startRow; k < startRow + 3; k++) {
                            for (int l = startColumn; l < startColumn + 3; l++) {
                                /*do not check solved cells*/
                                if (matrix[k][l] != 0) {
                                    continue;
                                }
                                boolean[] possibleValue = this.possibleValueList.get(k * 9 + l);
                                /*in case of 2 duplicate cells*/
                                if ((k == row && l == column) || (k == i && l == j)) {
                                    possibleValue[dupplicateValues[removedPosition] - 1] = true;
                                    continue;
                                }
                                /*In case of other unsolved cells*/
                                for (int m = 0; m < 3; m++) {
                                    if (m != removedPosition) {
                                        possibleValue[dupplicateValues[m] - 1] = true;
                                    }
                                }
                                int result = checkFound(possibleValue);
                                if (result > 0) {
                                    matrix[k][l] = result;
                                    textList.get(k * 9 + l).setText(result + "");
                                    finishedCell += 1;
                                    System.out.println("testDupicateTriple.SmallMatrix found " + result + " at position " + (k + 1) + "," + (l + 1));
                                }
                            }
                        }
                    }
                    break;
                }
            }
        }
        
    }

    /**
     * Use to backup matrix and possibleList
     *
     * @param matrix
     * @param possibleList
     * @param sourceMatrix
     * @param sourcePossibleList
     */
    private void duplicateLists(int[][] matrix, ArrayList<boolean[]> possibleList,
            int[][] sourceMatrix, ArrayList<boolean[]> sourcePossibleList) {
        for (int i = 0; i < 9; i++) {
            System.arraycopy(sourceMatrix[i], 0, matrix[i], 0, 9);
        }
        for (int i = 0; i < 81; i++) {
            boolean[] tmpArray = new boolean[9];
            System.arraycopy(sourcePossibleList.get(i), 0, tmpArray, 0, 9);
            possibleList.add(tmpArray);
        }
    }

    /**
     * Check if a matrix is a sudoku matrix or not
     *
     * @param matrix
     * @return
     */
    private boolean checkMatrix(int[][] matrix) {
        /*Check row*/
        for (int i = 0; i < 9; i++) {
            int total = 0;
            for (int j = 0; j < 9; j++) {
                total += matrix[i][j];
            }
            if (total != 55) {
                return false;
            }
        }
        /*Check column*/
        for (int i = 0; i < 9; i++) {
            int total = 0;
            for (int j = 0; j < 9; j++) {
                total += matrix[j][i];
            }
            if (total != 55) {
                return false;
            }
        }
        /*Check 9 small matrixes*/
        for (int i = 1; i < 4; i++) {
            for (int j = 1; j < 4; j++) {
                int total = 0;
                for (int k = 0; k < i * 3; k++) {
                    for (int l = 0; l < j * 3; l++) {
                        total += matrix[k][l];
                    }
                }
                if (total != 55) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * function of btnSolve
     *
     * @return
     */
    private boolean btnSolveAction() {
        /*Fill the matrix*/
        fillMatrix();
        /*Go through matrix*/
        int stopFlag = this.finishedCell;
        while (finishedCell < 81) {
            System.out.println("Found " + finishedCell + " cells.");
            /*Solve the matrix*/
            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    if (matrix[i][j] == 0) {
                        testCell(i, j);
                    }
                }
            }
            /*After go throught all cells, no more cell is solved, stop solving*/
            if (this.finishedCell == stopFlag) {
                break;
            }
            stopFlag = finishedCell;
        }
        return finishedCell == 81;
    }

    /**
     * Back the matrix to the backup version before guess
     *
     * @param tmpMatrix
     * @param tmpPossibleValues
     */
    private void resetMatrix(int[][] tmpMatrix, ArrayList<boolean[]> tmpPossibleValues) {
        matrix = new int[9][9];
        possibleValueList = new ArrayList<>();
        duplicateLists(matrix, possibleValueList, tmpMatrix, tmpPossibleValues);
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                String tmpText = matrix[i][j] > 0 ? matrix[i][j] + "" : "";
                this.textList.get(i * 9 + j).setText(tmpText);
            }
        }
    }

    /**
     * Get next cell to be guess
     *
     * @param row
     * @param column
     * @return
     */
    private int[] getNextEligibleCell(int row, int column) {
        int[] result = new int[4];
        for (int i = row; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if ((i == row && j <= column) || matrix[i][j] != 0) {
                    continue;
                }
                String possibleValue = this.getPossibleValue(i, j);
                if (possibleValue.length() == 2) {
                    result[0] = i;
                    result[1] = j;
                    result[2] = Integer.valueOf(possibleValue) / 10;
                    result[3] = Integer.valueOf(possibleValue) % 10;
                    return result;
                }
            }
        }
        return null;
    }

    /**
     * function of btnGuess
     *
     * @param currentRow
     * @param currentColumn
     * @param tmpMatrix
     * @param tmpPossibleValues
     */
    private void guess(int currentRow, int currentColumn, int[][] tmpMatrix, ArrayList<boolean[]> tmpPossibleValues) {
        /*Get next eligible cell*/
        int[] nextCell = this.getNextEligibleCell(currentRow, currentColumn);
        int row = nextCell[0];
        int column = nextCell[1];
        int firstPossibleValue = nextCell[2];
        int secondPossibleValue = nextCell[3];
        matrix[row][column] = firstPossibleValue;
        this.textList.get(row * 9 + column).setText(firstPossibleValue + "");
        System.out.println("=========Start guess for cell " + row + "," + column + " with value " + firstPossibleValue + "==========");
        if (this.btnSolveAction()) {
            if (!checkMatrix(matrix)) {
                System.out.println("Guess fail for value " + firstPossibleValue
                        + " for cell " + row + "," + column + " change to value " + secondPossibleValue);
                tmpMatrix[row][column] = secondPossibleValue;
                this.textList.get(row * 9 + column).setText(secondPossibleValue + "");
                this.resetMatrix(tmpMatrix, tmpPossibleValues);
                if (!this.btnSolveAction()) {
                    guess(row, column, tmpMatrix, tmpPossibleValues);
                }
            }
        } else {
            guess(row, column, tmpMatrix, tmpPossibleValues);
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnGuess;
    private javax.swing.JButton btnHideHint;
    private javax.swing.JButton btnLoadDefault;
    private javax.swing.JButton btnNew;
    private javax.swing.JButton btnShowHint;
    private javax.swing.JButton btnSolve;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel pnMain;
    // End of variables declaration//GEN-END:variables
}
